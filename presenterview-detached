#!/usr/bin/env python3

import tkinter as tk
from tkinter import messagebox as mb
import tkinter.font as tkFont
from tkinterhtml import HtmlFrame
import markdown
from PIL import Image,ImageTk,ImageDraw
from pdf2image import convert_from_path
from pathlib import Path
import os
import signal
import re
import time
import math
import subprocess
from datetime import datetime, timedelta
from tempfile import TemporaryDirectory,NamedTemporaryFile

from string import Template

class DeltaTemplate(Template):
    delimiter = "%"

def strfdelta(tdelta, fmt):
  # based on https://stackoverflow.com/a/30536361
  d = {"D": tdelta.days}
  hours, rem = divmod(tdelta.seconds, 3600)
  minutes, seconds = divmod(rem, 60)
  d["H"] = '{:02d}'.format(hours)
  d["M"] = '{:02d}'.format(minutes)
  d["S"] = '{:02d}'.format(seconds)
  d["f"] = '{:03d}'.format(int(tdelta.microseconds / 1000))
  t = DeltaTemplate(fmt)
  return t.substitute(**d)

class SlideView:
  def __init__(self, parent, controller):
    self.parent = parent
    self.controller = controller
    self.resize_from_update = False
    self.parent.bind('<KeyPress>', self.controller.onKeyPress)
    self.max_w = round(self.parent.winfo_screenwidth() * .97)
    self.max_h = round(self.parent.winfo_screenheight() * .94)
    self.frame = tk.Frame(self.parent, width=round(self.max_w * .75), height=self.max_h, bg="black")
    # ~ self.max_w = 1920
    # ~ self.max_h = 1080
    # ~ self.frame = tk.Frame(self.parent, width=self.max_w+6, height=self.max_h+6, bg="black")
    self.frame.pack(fill=tk.BOTH, expand=1)
    self.defaultbg = self.parent.cget('bg')

    self.cv1 = tk.Canvas(self.frame, highlightthickness=0)#, relief=tk.RAISED)
    self.cv1.pack(fill=tk.BOTH, expand=1)
    # ~ self.quitButton = tk.Button(self.frame, text = 'Quit', width = 25, command = self.close_windows)
    # ~ self.quitButton.pack()
    self.parent.bind('<Configure>', self.schedule_redraw)
    self.parent.protocol("WM_DELETE_WINDOW", self.close_window)
    self._after_id = None
    self.parent.update()
    self.parent.bind("<F11>", lambda event: self.parent.attributes("-fullscreen",
                                        not self.parent.attributes("-fullscreen")))
    self.parent.bind("<Escape>", lambda event: self.parent.attributes("-fullscreen", False))
    self.last_geom = "{}x{}".format(self.parent.winfo_width(), self.parent.winfo_height())
    # ~ self.last_geom = "1920x1080"
  
  def schedule_redraw(self, event):
    # ~ print(self.resize_from_update, event)
    if self._after_id:
      # ~ print(self._after_id)
      self.parent.after_cancel(self._after_id)
    if not self.resize_from_update:
      use_aspect_ratio = self.controller.get_keep_aspect_ratio()
      if use_aspect_ratio:
        new_h = round(int(event.width) / self.aspect_ratio)
        if new_h > self.max_h:
          new_h = self.max_h # if given height exceeds max, use max
        new_w = round(new_h * self.aspect_ratio) # derive width
        if new_w > self.max_w: # if it exceeds max width
          new_w = self.max_w # use max
          new_h = round(new_w / self.aspect_ratio) # and downsize height
        geom = "{}x{}".format(new_w, new_h)
      else:
        geom = "{}x{}".format(event.width, event.height)
      self._after_id = self.parent.after(2000, self.resize, False, geom, use_aspect_ratio)
      
      
  def init(self, pages, startslide):
    self.pages = pages
    self.startslide = int(startslide)
    self.current_slide = self.startslide
    self.resize(initial=True, geom=None)
    self.aspect_ratio = self.list_images[0].width() / self.list_images[0].height()
  
  def resize(self, initial=False, geom=None, resize_frame=False):
    if geom is None or geom != self.last_geom:
      if geom is not None:
        self.last_geom = geom
      if resize_frame:
        parted = geom.partition('x')
        new_w = int(parted[0])
        new_h = int(parted[2])
        if not self.resize_from_update:
          self.resize_from_update = True
          self.parent.geometry(geom)
      else:
        new_w = self.frame.winfo_width()
        new_h = self.frame.winfo_height()
      pic_width = new_w
      pic_height = new_h
      self.list_images = []
      # Storing the converted images into list
      max_w = 0
      for i in range(len(self.pages)):
        img = self.pages[i].copy()
        img.thumbnail((pic_width,pic_height), Image.ANTIALIAS)
        max_w = max(max_w, img.size[0])
        self.list_images.append(ImageTk.PhotoImage(img))
      self.list_images.append(self.controller.make_dummy(self.list_images[0].width(),self.list_images[0].height(), marked=False))
      self.cv1.config(width = self.list_images[0].width(), height=self.list_images[0].height())
      if self.parent.attributes("-fullscreen"):
        self.cv1.config(background="black")
      else:
        self.cv1.config(background=self.defaultbg)
      self.update_main_img()
  
  def update_main_img(self):
    im = self.list_images[self.controller.counter]
    # ~ self.cv1.delete("all")
    self.parent.update()
    self.cv1.create_image(self.cv1.winfo_width()/2, self.cv1.winfo_height()/2, anchor = tk.CENTER, image = im)
  
  def close_window(self):
    self.controller.close_window()
    
  def get_recording_geom(self):
    self.parent.update()
    im = self.list_images[self.controller.counter]
    x0 = self.frame.winfo_rootx() + round(self.cv1.winfo_width()/2) - round(im.width()/2)
    y0 = self.frame.winfo_rooty() + round(self.cv1.winfo_height()/2) - round(im.height()/2)
    return (im.width(),im.height(),x0,y0)


class PresenterView(tk.Frame):

  def __init__(self, parent, pdffile, startslide, *args, **kwargs):
    self.is_initialized = False

    tk.Frame.__init__(self, parent, *args, **kwargs)

    self.root = parent
    self.root.wm_title("Presenter")   
    # ~ self.root.attributes('-fullscreen', True)
    # enable shortcuts
    self.root.bind('<KeyPress>', self.onKeyPress)
    self.root.protocol("WM_DELETE_WINDOW", self.close_window)
    
    self.pdffile = pdffile

    self.rec_recorder = None
    self.rec_is_recording = False
    self.rec_is_paused = False
    self.rec_basepath = Path(self.pdffile).absolute().parent
    self.rec_basename = pdffile.replace('.pdf','')
    self.rec_timing_file = self.pdffile.replace('.pdf','-timing.chap')
    self.rec_timing_file_vtt = self.pdffile.replace('.pdf','.vtt')
    self.rec_timing_starttime = None
    self.rec_timing_markers = []
    
    self.md = markdown.Markdown()
    self.notes_font_size = 2
    
    self.timer_format = "%H:%M:%S"
    
    max_w = round(self.root.winfo_screenwidth() * .95)
    max_h = round(self.root.winfo_screenheight() * .91)
    this_w = round(max_w * .35)
    slide_w = round(max_w * .55)
    # ~ slide_w = 1926
    
    # todo initialize screen size correctly!
    self.slide_window = tk.Toplevel(self.root)
    self.slide_window.geometry("{}x{}+{}+{}".format(slide_w, #slide_w
                                max_h,
                                30, 
                                30))
    self.slide_viewer = SlideView(self.slide_window, self)
    self.root.bind("<F11>", lambda event: self.slide_window.attributes("-fullscreen",
                                        not self.slide_window.attributes("-fullscreen")))
    self.root.bind("<Escape>", lambda event: self.slide_window.attributes("-fullscreen", False))
    
    # ~ self.frame_left = tk.Frame(self.root, width=round(max_w * .75))
    # ~ self.frame_left.pack(fill=tk.BOTH, side=tk.LEFT, expand=1)
    
    self.frame_right = tk.Frame(self.root, width=this_w)
    self.frame_right.pack(fill=tk.BOTH, side=tk.LEFT, expand=0)
    self.frame2 = tk.Frame(self.frame_right)
    self.frame2.pack(fill=tk.X, expand=1)
    
    self.frame3 = tk.Frame(self.frame_right)
    self.frame3.pack(fill=tk.X, expand=1)

    self.cv2 = tk.Canvas(self.frame2, bd=1)#, relief=tk.RAISED)
    self.cv2.pack(fill=tk.Y, side=tk.LEFT, expand=1)
    self.frame4 = tk.Frame(self.frame2)
    self.frame4.pack(fill=tk.Y, side=tk.LEFT, expand=1)
    
    self.clock_font = tkFont.Font(family="Lucida Grande", size=20)
    
    self.clock_label = tk.Label(self.frame4, text=datetime.strftime(datetime.now(),self.timer_format), font=self.clock_font)
    self.clock_label.pack()
    
    self.recording_timer_label = tk.Label(self.frame4, text="00:00:00", font=self.clock_font)
    self.recording_timer_label.pack()
    
    self.btn_text = tk.StringVar()
    self.btn = tk.Button(self.frame4, textvariable = self.btn_text, command = self.toggle_recording)
    self.btn_text.set("Start Recording")
    self.btn.pack()
    self.additional_source_animated_slides = tk.IntVar(value=0)
    self.additional_source_animated_slides_check = tk.Checkbutton(self.frame4, text="Animated slides", variable=self.additional_source_animated_slides)
    self.additional_source_animated_slides_check.pack()
    
    self.additional_source_webcam = tk.IntVar(value=0)
    self.additional_source_webcam_check = tk.Checkbutton(self.frame4, text="Webcam on /dev/video0", variable=self.additional_source_webcam)
    self.additional_source_webcam_check.pack()
    
    self.additional_source_another_region = tk.IntVar(value=0)
    self.additional_source_another_region_check = tk.Checkbutton(self.frame4, text="Another region of the screen:", variable=self.additional_source_another_region)
    self.additional_source_another_region_check.pack()
    
    self.second_offset_entry = tk.Entry(self.frame4)
    self.second_offset_entry.pack()
    
    self.btn_write_vtt = tk.IntVar(value=0)
    self.btn_write_vtt_check = tk.Checkbutton(self.frame4, text="Produce WebVTT file during recording", variable=self.btn_write_vtt)
    self.btn_write_vtt_check.pack()
    
    self.btn_rec_pause_text = tk.StringVar()
    self.btn_rec_pause = tk.Button(self.frame4, textvariable = self.btn_rec_pause_text, command = self.toggle_recording_pause)
    self.btn_rec_pause_text.set("Pause Recording")
    self.btn_rec_pause.pack()
    
    self.btn_fs = tk.Button(self.frame4, text = "Toggle Slide Fullscreen", command = lambda: self.slide_window.attributes("-fullscreen",
                                                                                                    not self.slide_window.attributes("-fullscreen")))
    self.btn_fs.pack()
    
    
    self.btn_rn_text = tk.StringVar()
    self.btn_rn = tk.Button(self.frame4, textvariable = self.btn_rn_text, command = self.update_notes)
    self.btn_rn_text.set("Reload Notes")
    self.btn_rn.pack()
    
    self.new_geometry_entry = tk.Entry(self.frame4)
    self.new_geometry_entry.pack()
    self.btn_rs_text = tk.StringVar()
    self.btn_rs = tk.Button(self.frame4, textvariable = self.btn_rs_text, command = self.resize_to_input)
    self.btn_rs_text.set("Resize to Geometry")
    self.btn_rs.pack()
    
    self.btn_keep_aspect_ratio = tk.IntVar(value=1)
    self.btn_keep_aspect_ratio_check = tk.Checkbutton(self.frame4, text="Keep Aspect Ratio of Slides when Resizing", variable=self.btn_keep_aspect_ratio)
    self.btn_keep_aspect_ratio_check.pack()
    
    self.notes_txt = HtmlFrame(self.frame3)
    self.notes_txt.pack(side=tk.LEFT, fill=tk.BOTH, expand=0)
    self.frame5 = tk.Frame(self.frame3, width=30)
    self.frame5.pack(fill=tk.BOTH, side=tk.LEFT, expand=1)
    self.btn_font_plus  = tk.Button(self.frame5, text = "+", command = self.notes_fontsize_increase)
    self.btn_font_minus = tk.Button(self.frame5, text = "-", command = self.notes_fontsize_decrease)
    self.btn_font_plus.pack(fill=tk.BOTH, expand=1)
    self.btn_font_minus.pack(fill=tk.BOTH, expand=1)
    
    self.root.update()
    geom = "{}x{}+{}+{}".format(this_w, 
                                max_h,
                                slide_w+60, 
                                30)
    self.root.geometry(geom)
    self.root.update()
    self._after_id = None
    self.root.after(500, self.load_and_init, startslide, max_h)
  
  def get_keep_aspect_ratio(self):
    if self.is_initialized:
      return self.btn_keep_aspect_ratio.get() == 1
    else:
      return False
  
  def get_record_animated_slides(self):
    if self.is_initialized:
      return self.additional_source_animated_slides.get() == 1
    else:
      return False
  
  def get_record_webcam(self):
    if self.is_initialized:
      return self.additional_source_webcam.get() == 1
    else:
      return False
  
  def get_record_second_region(self):
    if self.is_initialized:
      return self.additional_source_another_region.get() == 1
    else:
      return False
  
  def get_write_vtt(self):
    if self.is_initialized:
      return self.btn_write_vtt.get() == 1
    else:
      return False
  
  def schedule_redraw(self, event):
    if self._after_id:
        self.after_cancel(self._after_id)
    if event.width != 30000 and event.height != 30000:
      self._after_id = self.after(2000, self.resize)
  
  def load_and_init(self, startslide, max_h):
    # Here the PDF is converted to list of images
    self.pages = convert_from_path(self.pdffile,size=(None, max_h*2.0),dpi=300)
    self.counter = int(startslide)-1
    self.max_count = len(self.pages)
    self.slide_viewer.init(self.pages, self.counter)
    self.notes = self.load_notes(self.pdffile, len(self.pages))
    self.update_notes(False)
    self.update_clock()
    self.resize(initial=True)
    self.root.bind('<Configure>', self.schedule_redraw)
    self.is_initialized = True
  
  def resize_to_input(self):
    other_geom = self.new_geometry_entry.get() # 1178x730+154+327
    if other_geom != '' and 'x' in other_geom:
      self.slide_viewer.resize(geom=other_geom, resize_frame=True)
    
  
  def resize(self, initial=False):
    # call self
    if initial:
      self.list_preview_images = []
      prev_pic_width = self.cv2.winfo_width()
      prev_pic_height = self.cv2.winfo_height()
      # Create Preview images
      for i in range(len(self.pages)):
        img = self.pages[i].copy()
        img.thumbnail((prev_pic_width,prev_pic_height), Image.ANTIALIAS)
        self.list_preview_images.append(ImageTk.PhotoImage(img))
      # append a black screen at the end
      self.list_preview_images.append(self.make_dummy(self.list_preview_images[0].width(),self.list_preview_images[0].height(), marked=False))
      self.list_preview_images.append(self.make_dummy(self.list_preview_images[0].width(),self.list_preview_images[0].height()))
    if len(self.pages) >= 2:
      self.update_preview_img()
    
    # ~ if not initial:
      # ~ self.frame_left.config(width=max_w)
      # ~ self.frame_right.config(width=self.root.winfo_width()-max_w)
      # ~ self.notes_txt.config(width=self.root.winfo_width()-max_w-30)

  def toggle_recording_pause(self):
    if self.rec_is_recording:
      if self.rec_is_paused:
        self.btn_rec_pause_text.set("Pause Recording")
        self.rec_is_paused = False
        os.kill(self.rec_recorder.pid, signal.SIGCONT)
      else:
        self.btn_rec_pause_text.set("Resume Recording")
        self.rec_is_paused = True
        os.kill(self.rec_recorder.pid, signal.SIGSTOP)
        
  
  def join_video_audio(self, v, a, o, a_offset='00:00.00', v_offset='00:00.00', a_cut=False, v_cut=False, a_start='00:00.00', v_start='00:00.00'):
    cmd = ['ffmpeg','-y',
         '-itsoffset',v_offset,'-ss',v_start]
    if v_cut is not False:
      cmd.extend(['-t',v_cut])
    cmd.extend(['-i',v,
         '-itsoffset',a_offset,'-ss',a_start])
    if a_cut is not False:
         cmd.extend(['-t',a_cut])
    cmd.extend(['-i',a,
         '-map','0:v','-map','1:a','-c','copy', o])
    print(cmd)
    rec_joiner = subprocess.Popen(cmd, cwd=self.rec_basepath, stdout=subprocess.PIPE)
    rec_joiner.communicate()
    # ~ if a_start != '00:00.00' and v_start != '00:00.00':
      # ~ ext = Path(o).suffix
      # ~ rec_joiner = subprocess.Popen(['ffmpeg','-y','-i',o,'-start_at_zero','-map','0:v','-c:v','copy','-map','0:a','-c:a','copy','arg'+ext], cwd=self.rec_basepath, stdout=subprocess.PIPE)
      # ~ rec_joiner.communicate()
  
  def produce_recording(self):
    if not self.get_record_animated_slides():
      if mb.askyesno("Recording finished", "Do you want to produce the slideshow file right away?"):
        with TemporaryDirectory() as tmpdir:
          i=0
          w=0
          h=0
          for i,page in enumerate(self.pages):
            fname = '{}/slide-{:03d}.png'.format(tmpdir,i)
            h = min(self.root.winfo_screenheight(), 1080)
            w = int(round(h * page.width / page.height))
            img = page.resize((w,h), Image.ANTIALIAS)
            img.save(fname, 'png', compress_level=6)
          fname = '{}/slide-{:03d}.png'.format(tmpdir,i+1)
          img = ImageTk.getimage(self.make_dummy(w,h, marked=False))
          img.save(fname, 'png', compress_level=9)
          cmd = ["chap2ffconcat", self.rec_timing_file, '{}/slide-{{:03d}}.png'.format(tmpdir)]
          with NamedTemporaryFile() as tmpfile: 
            subprocess.run(cmd, stdout=tmpfile, cwd=self.rec_basepath)
            ts = str(math.floor(self.rec_timing_markers[-1].total_seconds()))
            cmd = ['ffmpeg','-y','-safe','0','-f','concat','-i',tmpfile.name,'-t',ts,'-c:v','libx264','-vf','format=yuv420p','-fflags','+genpts','-movflags','+faststart',self.rec_basename+'-screen.mp4']
            # ~ cmd = ['ffmpeg','-y','-safe','0','-f','concat','-i',tmpfile.name,'-c:v','libx264','-vf','format=yuv420p','-fflags','+genpts','-movflags','+faststart',self.rec_basename+'-screen.mp4']
            rec_producer = subprocess.Popen(cmd, cwd=self.rec_basepath)
            rec_producer.communicate()

      if mb.askyesno("Join video and audio?", "Do you want to join slideshow and audio now?"):
        diff = self.rec_timing_starttime - self.rec_audio_start
        self.join_video_audio(self.rec_basename+'-screen.mp4', self.rec_basename+'-audio.flac', self.rec_basename+'-slides-audio.mkv', v_offset = strfdelta(diff, "%H:%M:%S.%f"))
        mb.showinfo("Done","Merging audio and video is done")
        
      # appears as if recording x11 AND webcam requires other offsets...
      if self.get_record_webcam():
        if mb.askyesno("Join video and audio?", "Do you want to join webcam video and audio?"):
          # ~ diff = self.rec_audio_start - self.rec_webcam_start
          # ~ diff += timedelta(seconds=1)
          # ~ diff = strfdelta(diff, "%H:%M:%S.%f")
          # ~ self.join_video_audio(self.rec_basename+'-webcam.mkv', self.rec_basename+'-audio.flac', self.rec_basename+'-webcam-audio.mkv', v_start = diff, a_start = diff, a_offset='00:00.50')
          self.join_video_audio(self.rec_basename+'-webcam.mkv', self.rec_basename+'-audio.flac', self.rec_basename+'-webcam-audio.mkv', a_offset='00:00.50')
          mb.showinfo("Done","Merging audio and video is done")
        
    elif mb.askyesno("Join video and audio?", "Do you want to join slides-video and audio now?"):
      ts = str(math.floor(self.rec_timing_markers[-1].total_seconds()))
      self.join_video_audio(self.rec_basename+'-screen.mkv', self.rec_basename+'-audio.flac', self.rec_basename+'-screen-audio.mkv', v_cut=ts)
      mb.showinfo("Done","Merging audio and video is done")
      
      if self.get_record_webcam():
        if mb.askyesno("Join video and audio?", "Do you want to join webcam video and audio?"):
          self.join_video_audio(self.rec_basename+'-webcam.mkv', self.rec_basename+'-audio.flac', self.rec_basename+'-webcam-audio.mkv', v_offset='-00:01.00')
          mb.showinfo("Done","Merging audio and video is done")
    
  
  def ffmpeg_configure_and_start(self):
    geom = self.slide_viewer.get_recording_geom()
    if geom[0] % 2 != 0:
      geom = (geom[0]-1, geom[1], geom[2]+1, geom[3])
    if geom[1] % 2 != 0:
      geom = (geom[0], geom[1]-1, geom[2], geom[3]+1)
    # ~ geom = "{}x{}+{}+{}".format(geom[0]-6,
                                # ~ geom[1]-6,
                                # ~ geom[2]+3,
                                # ~ geom[3]+3)
    other_geom = self.second_offset_entry.get() # 1178x730+154+327
    
    screenCodec="libx264"
    screenOptions="-preset ultrafast -qp 0 -pix_fmt yuv444p"
    webcamCodec="libx265"
    webcamOptions="-preset fast -crf 26"
    webcamSize="960x540"
    webcamSource="/dev/video0"
    
    audioFile  = self.rec_basename+'-audio.flac'
    screenFile = self.rec_basename+'-screen.mkv'
    screen_otherFile = self.rec_basename+'-screen2.mkv'
    webcamFile = self.rec_basename+'-webcam.mkv'
    
    i_audio = "-f alsa -ac 1 -ar 48000 -thread_queue_size 2048 -i sysdefault:CARD=CM900"
    # ~ i_audio = "-f alsa -ac 1 -ar 48000 -thread_queue_size 1024 -i default"
    # ~ i_audio = "-f pulse -thread_queue_size 1024 -i alsa_input.usb-Auna_Mic_CM900_Auna_Mic_CM900-00.mono-fallback" # analog-input-mic
    i_screen = f"-f x11grab -show_region 0 -video_size {geom[0]}x{geom[1]} -r 4 -thread_queue_size 1024 -i :0.0+{geom[2]},{geom[3]}"
    i_webcam = f"-f v4l2 -ts abs -video_size {webcamSize} -thread_queue_size 1024 -i {webcamSource}"
    
    o_screen = f"-c:v {screenCodec} {screenOptions} {screenFile}"
    o_screen_other = f"-c:v {webcamCodec} {webcamOptions} {screen_otherFile}"
    o_webcam = f"-c:v {webcamCodec} {webcamOptions} {webcamFile}"
    
    
    n_audio = 0
    n_screen = 0
    n_webcam = 0
    
    cmd = f"ffmpeg -y"
    out_map = ""
    i_n = 0
    
    if self.get_record_webcam():
      cmd += ' '+i_webcam
      out_map += ' '+f"-map {i_n}:v:0 {o_webcam}"
      i_n += 1
      
    if self.get_record_second_region():
      other_geom = other_geom.strip().split('+')
      xy = other_geom[0].split('x')
      cmd += ' '+f"-f x11grab -show_region 1 -video_size {xy[0]}x{xy[1]} -r 25 -thread_queue_size 1024 -i :0.0+{other_geom[1]},{other_geom[2]}"
      out_map += ' '+f"-map {i_n}:v:0 {o_screen_other}"
      i_n += 1
      
    if self.get_record_animated_slides():
      cmd += ' '+i_screen
      out_map += ' '+f"-map {i_n}:v:0 {o_screen}"
      i_n += 1
      
    cmd += ' '+i_audio
    out_map += ' '+f"-map {i_n}:a:0 {audioFile}"
    
    cmd = cmd + out_map
    print(cmd)
    
    # ~ wait_for_start = False
    wait_for_start = self.get_record_webcam() or self.get_record_second_region()
    if wait_for_start:
      self.rec_recorder = subprocess.Popen(cmd.split(' '), stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
    else:
      self.rec_recorder = subprocess.Popen(cmd.split(' '))
      self.rec_audio_start = datetime.now()
      self.rec_webcam_start = None
    while wait_for_start:
      for line in self.rec_recorder.stdout:
        print(line.strip())
        m = re.match( r'^Output [^\']*\''+audioFile+'\'', line, re.M)
        if m:
          self.rec_audio_start = datetime.now()
        m = re.match( r'^Output [^\']*\''+webcamFile+'\'', line, re.M)
        if m:
          self.rec_webcam_start = datetime.now()
        m = re.match( r'^(frame|size)= *\d+', line, re.M)
        if m:
          wait_for_start = False
          break
  
  def toggle_recording(self):
    if self.rec_is_recording:
      self.btn_text.set("Start Recording")
      self.log_timing(marker="END")
      self.rec_is_recording = False
      if self.rec_recorder:
        if self.get_record_webcam():
          time.sleep(1)
        if self.get_record_animated_slides():
          time.sleep(3)
        # ~ self.rec_recorder.terminate()
        os.kill(self.rec_recorder.pid, signal.SIGINT)
        while self.rec_recorder.poll() is None:
          pass
      self.produce_recording()
      self.rec_timing_starttime = None
    else:
      self.btn_text.set("Stop Recording")
      self.ffmpeg_configure_and_start()
      self.rec_is_recording = True
      self.log_timing(start=True)
  
  def log_timing(self, marker=None, start=False):
    if start:
      self.rec_timing_starttime = datetime.now()
      with open(self.rec_timing_file, 'w') as tf:
        print("{} S".format(self.rec_timing_starttime), file=tf)
      if self.get_write_vtt():
        with open(self.rec_timing_file_vtt, 'w') as tf:
          print("WEBVTT\n\n", file=tf)
    if self.rec_is_recording:
      diff = datetime.now() - self.rec_timing_starttime
      last = self.rec_timing_markers[-1] if len(self.rec_timing_markers) > 0 else self.rec_timing_starttime - self.rec_timing_starttime
      self.rec_timing_markers.append(diff)
      out_mark = self.counter + 1 if marker is None else marker
      with open(self.rec_timing_file, 'a') as tf:
        print("{} {}".format(strfdelta(diff, "%H:%M:%S.%f"), out_mark), file=tf)
      if self.get_write_vtt():
        with open(self.rec_timing_file_vtt, 'a') as tf:
          print("{}\n{} --> {}\n".format(out_mark, strfdelta(last, "%H:%M:%S,%f"), strfdelta(diff, "%H:%M:%S,%f")), file=tf)
    
  
  def next_image(self):
    if self.counter < self.max_count:
      self.counter += 1
      self.slide_viewer.update_main_img()
      self.update_preview_img()
      self.update_notes(False)
      self.log_timing()

  def previous_image(self):
    if self.counter > 0:
      self.counter -= 1
      self.slide_viewer.update_main_img()
      self.update_preview_img()
      self.update_notes(False)
      self.log_timing()

  def notes_fontsize_increase(self):
    self.notes_font_size += 2
    self.update_notes(False)
    
  def notes_fontsize_decrease(self):
    self.notes_font_size -= 2
    self.update_notes(False)
    
  def update_notes(self, reload=True):
    if reload:
      self.notes = self.load_notes(self.pdffile, len(self.pages))
    self.notes_txt.set_content('<html></html>')
    i = str(self.counter+1)
    if i in self.notes:
      self.notes_txt.set_content('<html><font size="+{}">{}</font></html>'.format(self.notes_font_size,self.md.convert((''.join(self.notes[i])).strip())))

  def onKeyPress(self, event):
    kc = event.keycode
    ch = event.char
    if kc == 114 or kc == 116 or ch == 'n':
      self.next_image()
    elif kc == 111 or kc == 113 or ch == 'p':
      self.previous_image()
    elif ch == '+':
      self.notes_fontsize_increase()
    elif ch == '-':
      self.notes_fontsize_decrease()
    elif ch == 'r':
      self.toggle_recording()
    elif ch == 'x':
      self.log_timing('X')

  def update_preview_img(self):
    imprev = self.list_preview_images[self.counter + 1]
    if self.counter > 0:
      self.cv2.delete("all")
    self.cv2.create_image(0, 0, anchor = 'nw', image = imprev)

  def update_clock(self):
    now = datetime.now()
    self.clock_label.configure(text=datetime.strftime(now,self.timer_format))
    if self.rec_is_recording:
      diff = now - self.rec_timing_starttime
      diff = str(diff).split('.')[0]
      self.recording_timer_label.configure(text = datetime.strftime(datetime.strptime(diff, "%H:%M:%S"), self.timer_format))
    self.root.after(1000, self.update_clock)

  def load_notes(self, filename, n_slides):
    notes = {}
    p = Path(filename.replace('.pdf', '.notes'))
    if p.exists():
      cur = []
      cur_s = None
      with open(p,'r') as _f:
        for line in _f:
          m = re.match( r'^#\s*(\d+)', line, re.M)
          if m:
            if cur_s in notes:
              raise Exception('slide has more than one notes section')
            if cur_s is not None:
              notes[cur_s] = cur
            cur = []
            cur_s = (m.group(0)).replace('#','').strip()
          else:
            cur.append(line)
        notes[cur_s] = cur
    return notes
      

  def make_dummy(self, width, height, marked=True):
    img = Image.new('RGB', (width,height), (0,0,0))
    if marked:
      draw = ImageDraw.Draw(img)
      draw.line((0,height, width, 0), fill=128, width=3)
    return ImageTk.PhotoImage(img)
    
  def close_window(self):
    if self.rec_is_recording:
      self.rec_recorder.terminate()
    self.root.destroy()
    

def main(pdffile, startslide=1):
    root = tk.Tk() 
    MyApp = PresenterView(root, pdffile, startslide)
    tk.mainloop()


if __name__=='__main__':
  import plac
  plac.call(main)
